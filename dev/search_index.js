var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = MPIParticleInCell","category":"page"},{"location":"#MPIParticleInCell","page":"Home","title":"MPIParticleInCell","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [MPIParticleInCell]","category":"page"},{"location":"#MPIParticleInCell.AbstractGrid","page":"Home","title":"MPIParticleInCell.AbstractGrid","text":"Stores global and per-rank information about a grid imposed over a simulation domain.\n\n\n\n\n\n","category":"type"},{"location":"#MPIParticleInCell.Field","page":"Home","title":"MPIParticleInCell.Field","text":"Field(grid, name, data_type, full_field_on_root)\n\nCreates a distributed array of type data_type with dimensions specified by grid. If full_field_on_root is true, then the root node allocates memory the entire array, although in normal operation it only utilizes the portion of memory that it is assigned to update. Obviously, care must be taken to not use this option for large simulations.\n\n\n\n\n\n","category":"type"},{"location":"#MPIParticleInCell.UniformGrid","page":"Home","title":"MPIParticleInCell.UniformGrid","text":"UniformGrid(lower_dims, upper_dims, num_cells, num_guard_cells, periodic)\n\nStores global and per-rank information about a uniform N-dimensional spatial grid.\n\n\n\n\n\n","category":"type"},{"location":"#MPIParticleInCell.communicate_halo!-Tuple{Field, Any}","page":"Home","title":"MPIParticleInCell.communicate_halo!","text":"communicate_halo!(f::Field, comm)\n\nCommunicates the values of each processors guard cells to its neighbors.\n\n\n\n\n\n","category":"method"},{"location":"#MPIParticleInCell.compute_proc_bounds-Tuple{Any, Any, Any}","page":"Home","title":"MPIParticleInCell.compute_proc_bounds","text":"compute_proc_bounds(num_cells, proc_dims, proc)\n\nComputes the range of cells that proc is responsible for.\n\n\n\n\n\n","category":"method"},{"location":"#MPIParticleInCell.compute_proc_indices-Tuple{Any, Any}","page":"Home","title":"MPIParticleInCell.compute_proc_indices","text":"compute_proc_indices(proc_dims, proc)\n\nComputes the unique indices in the processor grid for proc.\n\n\n\n\n\n","category":"method"},{"location":"#MPIParticleInCell.compute_proc_rank-Tuple{Any, Any}","page":"Home","title":"MPIParticleInCell.compute_proc_rank","text":"compute_proc_rank(proc_dims, indices)\n\nComputes the rank associated with the processor at indices.\n\n\n\n\n\n","category":"method"},{"location":"#MPIParticleInCell.compute_processor_dimensions-Union{Tuple{N}, Tuple{Tuple{Vararg{T, N}} where T, Any}} where N","page":"Home","title":"MPIParticleInCell.compute_processor_dimensions","text":"compute_processor_dimensions(num_cells::NTuple{N}, num_procs)\n\nGiven the desired number of cells in each dimension, and a number of processors, returns the number of subdivisions along each dimension that minimize the amount of inter-rank communication.\n\n\n\n\n\n","category":"method"},{"location":"#MPIParticleInCell.decompose_domain-Union{Tuple{N}, Tuple{Tuple{Vararg{T, N}} where T, Any}} where N","page":"Home","title":"MPIParticleInCell.decompose_domain","text":"decompose_domain(num_cells::NTuple{N}, num_procs[, proc])\n\nGiven a target number of pieces num_procs and an N-cube simulation domain with num_cells along each dimension, computes a decomposition of the domain. If proc is specified, returns a pair of Tuples corresponding to the lower and upper bounds of the cells assigned to proc. Otherwise, returns a pair of vectors of the lower and upper bounds for each processor.\n\nNOTE: proc is zero indexed.\n\n\n\n\n\n","category":"method"},{"location":"#MPIParticleInCell.gather_field_on_root!-Tuple{Field}","page":"Home","title":"MPIParticleInCell.gather_field_on_root!","text":"gather_field_on_root!(f::Field)\n\nGathers the entire field f on the root node. Can only be used if f was created with full_field_on_root = true.\n\n\n\n\n\n","category":"method"}]
}
